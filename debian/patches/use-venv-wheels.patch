Description: When inside a virtual environment (venv), we need to add
 all the recursively devendorized dependent wheels to sys.path so that they
 can be imported.  These should not live outside the venv (i.e. in system
 paths) in order to preserve venv isolation.  This patch works with the
 following scenarios: Python 2 (virtualenv), Python 3 (virtualenv, pyvenv).
Author: Barry Warsaw <barry@debian.org>
Forwarded: not-needed

--- a/pip/__init__.py
+++ b/pip/__init__.py
@@ -5,6 +5,53 @@
 import sys
 import re
 
+# Debian virtual environment (venv) support.  When inside a venv, we have to
+# add all the devendorized wheels to sys.path from inside the venv, otherwise
+# the devendorized packages won't be found.  Only do this in a venv so it
+# doesn't affect global pip operation.  venv determination is a bit of a black
+# art, but this algorithm should work in both Python 2 (virtualenv-only) and
+# Python 3 (pyvenv and virtualenv).  - barry@debian.org 2014-06-03
+base_prefix = getattr(sys, 'base_prefix', None)
+real_prefix = getattr(sys, 'real_prefix', None)
+if base_prefix is None:
+    # Python 2 has no base_prefix at all.  It also has no pyvenv.  Fall back
+    # to checking real_prefix.
+    if real_prefix is None:
+        # We are not in a venv.
+        in_venv = False
+    else:
+        # We're in a Python 2 virtualenv created venv, but real_prefix should
+        # never be the same as sys.prefix.
+        assert sys.prefix != real_prefix
+        in_venv = True
+elif sys.prefix != base_prefix:
+    # We're in a Python 3, pyvenv created venv.
+    in_venv = True
+elif real_prefix is None:
+    # We're in Python 3, outside a venv, but base better equal prefix.
+    assert sys.prefix == base_prefix
+    in_venv = False
+else:
+    # We're in a Python 3, virtualenv created venv.
+    assert real_prefix != sys.prefix
+    in_venv = True
+
+
+if in_venv:
+    wheel_dir = os.path.join(sys.prefix, 'lib', 'python-wheels')
+    # We'll add all the wheels we find to the front of sys.path so that
+    # they're found first, even if the same dependencies are available in
+    # site-packages.  When pyvenv initializes the venv by calling `$python -Im
+    # ensurepip`, it'll only copy the wheels needed to make pip work into this
+    # directory, so we can just add them all.
+    try:
+        for filename in os.listdir(wheel_dir):
+            if os.path.splitext(filename)[1] == '.whl':
+                sys.path.insert(0, os.path.join(wheel_dir, filename))
+    except FileNotFoundError:
+        # Oh well.
+        pass
+
 from pip.exceptions import InstallationError, CommandError, PipError
 from pip.log import logger
 from pip.util import get_installed_distributions, get_prog
--- a/setup.py
+++ b/setup.py
@@ -41,7 +41,13 @@
 long_description = "\n" + "\n".join([read('PROJECT.txt'),
                                      read('docs', 'quickstart.rst')])
 
-tests_require = ['pytest', 'virtualenv>=1.10', 'scripttest>=1.3', 'mock']
+tests_require = ['pytest', 'scripttest>=1.3', 'mock']
+
+# In Debian, the virtualenv Build-Depends will satisfy this requirement
+# but setup() is too dumb to notice that.
+if sys.version_info < (3,):
+    tests_require.append('virtualenv>=1.10')
+
 
 setup(name="pip",
       version=find_version('pip', '__init__.py'),
